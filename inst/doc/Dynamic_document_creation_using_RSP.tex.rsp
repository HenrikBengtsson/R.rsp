<%-------------------------------%><%@eval language="R-vignette" text="
  DIRECTIVES FOR R:

  %\VignetteIndexEntry{Dynamic document creation using RSP}
  %\VignetteKeyword{RSP markup language, literate programming, reproducible research, report generator, Sweave, knitr, TeX, LaTeX, Markdown, HTML, AsciiDoc, reStructuredText, Org-Mode, PDF}
  %\VignetteEngine{R.rsp::rsp}
"%><%----------------------------------------------------------------%>

<% t0 <- Sys.time() %>


<%-------------------------------------------------------------------
  RELEASE OR DEVEL?
  ARTICLE OR SLIDES?
  -------------------------------------------------------------------%>
<%@define docVersion="${'R.rsp/vignettes/docVersion'}" default=""%>
<%@define docMode="${'R.rsp/vignettes/docMode'}" default="article"%>
<%@ifeq docMode = "slides"%>
\documentclass[a5paper,12pt,landscape]{article}
<%@else%>
\documentclass[letter,12pt]{article}
<%@endif%>

\usepackage{graphicx}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{alltt}
\graphicspath{{figures/}}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

<%-------------------------------------------------------------------
  DOCUMENT MODE SPECIFIC SETTINGS
  -------------------------------------------------------------------%>
<%@ifeq docMode = "slides"%>
% Adjust margins
\addtolength{\oddsidemargin}{-0.75in}	
\addtolength{\evensidemargin}{-0.75in}	
\addtolength{\textwidth}{1.5in}
\addtolength{\topmargin}{-1.3in}	
\addtolength{\textheight}{2.3in}

% Adjust the title to appear higher up
\usepackage{titling} % \droptitle
\setlength{\droptitle}{-9ex}

% Add a \clearpage before each \section{}
\makeatletter
\renewcommand{\section}{\@startsection
{section}
{1}
{0mm}
{-3.5ex \@plus -1ex \@minus -.2ex}
{2.3ex \@plus.2ex}
{\clearpage\normalfont\Large\bfseries}}
\makeatother

% Fonts
%%\usepackage{mathptmx}  % times roman, including math (where possible)
%%\usepackage{mathpazo}  % palatino, including math (where possible)
%% \usepackage{helvetica}    % helvetica
\renewcommand{\familydefault}{\sfdefault}
<%@else%>
% Adjust margins
\addtolength{\oddsidemargin}{-0.5in}	
\addtolength{\evensidemargin}{-0.5in}	
\addtolength{\textwidth}{1in}
\addtolength{\topmargin}{-0.5in}	
\addtolength{\textheight}{1in}
<%@endif%> <%-- docMode --%>



%% \setlength{\parindent}{0in} 
%% \setlength{\parskip}{\baselineskip}


\newcommand{\keywords}[1]{\footnotesize{\textbf{Keywords: }#1}\xspace}
\newcommand{\pkg}[1]{\textsl{#1}\xspace}
\newcommand{\code}[1]{\texttt{#1}\xspace}
\newcommand{\bs}{$\backslash$}
\newcommand{\lb}{\linebreak[0]}

\newenvironment{rspVerbatim}{\vspace{-\parskip}\begin{alltt}\color{blue}}{\end{alltt}}
\newenvironment{escapeRspVerbatim}{\vspace{-\parskip}\begin{alltt}}{\end{alltt}}



<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Set default graphics options
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Use greater objects by default
setOption("devNew/args/par", list(lwd=2));

# Change the default dimensions for PNGs
devOptions("png", width=840)
%>


\title{<%@title%><%@ifeq docVersion = "devel"%>*<%@endif%>}
\author{Henrik Bengtsson}
\date{<%=format(as.Date(getDate(R.rsp)), format="%B %d, %Y")%>}

\begin{document}

\maketitle
\begin{abstract}
An important part of a statistical analysis is to document the analysis and its results.  A common approach is to build up an R script as the the analysis progresses.  This script may generate image files and tables that are later inserted manually into, say, a LaTeX report.  This strategy works alright for small one-off analyzes, whereas for larger and partly repetitive analyzes an automatic report generator is more suitable.

In this document we introduce the RSP markup language and explain how it can be embedded in virtually any text-based source document which then may be compile into a final document.  We will describe all of the RSP constructs available and illustrate how to they can be used for plain text as well as for LaTeX documents.

RSP provides an easy, yet powerful and flexible way for generating reports and other documents in R.  With a single R command it is possible to compile an RSP-embedded LaTeX, Sweave or knitr document into a read-to-view PDF file to name a few examples.  As an example, we show how to produce this very document from an RSP-embedded LaTeX file.

Furthermore, because RSP is a so called content-indepent markup language, it can be used to produce documents of any kind, e.g. plain text, LaTeX, Sweave, knitr, AsciiDoc, Markdown, HTML, XML, SVG, and even Javascript, R scripts and so on.  More over, with RSP it is possible to use literate programming constructs that are not possible in Sweave, e.g. looping over a mix of R source code and LaTeX text blocks.
\end{abstract}

\keywords{<%@keywords%>}

\begin{center}
\emph{This vignette is distributed as part of the \pkg{R.rsp} package, which is available on CRAN.}
\end{center}

\clearpage
\tableofcontents

\clearpage

<%-------------------------------------------------------------------
  INTRODUCTION
  -------------------------------------------------------------------%>
\section{Introduction to RSP}
The RSP markup language makes it possible to interweave text and R source code in a compact and powerful way for the purpose of generating text of any format.
An example of an RSP-embedded string is
\begin{rspVerbatim}
"A random integer in [1,100]: <\%=sample(1:100, size=1)\%>{\bs}n"
\end{rspVerbatim}
Using the \pkg{R.rsp} package\footnote{To install the \pkg{R.rsp} package, call \code{install.packages("R.rsp")} at the R prompt.}, this RSP string can be processed and outputted as
\begin{escapeRspVerbatim}
> library("R.rsp")
> rcat("A random integer in [1,100]: <\%=sample(1:100, size=1)\%>{\bs}n")
A random integer in [1,100]: 77
\end{escapeRspVerbatim}
As explained further in Section~\ref{RspMarkupLanguage}, the RSP construct \code{<\%=\{code chunk\}\%>} causes the R expression '\code{\{code chunk\}}' to be evaulated and its value to be inserted into the text (replacing the RSP construct).
%
To process the RSP string without outputting the result, but instead returning it in a character string, do
\begin{escapeRspVerbatim}
> s <- rstring("A random integer in [1,100]: <\%=sample(1:100, size=1)\%>{\bs}n")
> cat(s)
A random integer in [1,100]: 43
\end{escapeRspVerbatim}



%% \section{Compiling RSP documents to files}
\subsection{rfile()}
Consider an RSP-embedded text file \code{random.txt.rsp} that contains the above RSP string, i.e.
\begin{rspVerbatim}
A random integer in [1,100]: <\%=sample(1:100, size=1)\%>
\end{rspVerbatim}
This file can be compiled as
\begin{verbatim}
> rfile("random.txt.rsp")
\end{verbatim}
which generates a plain text file (\code{random.txt}) that contains
\begin{escapeRspVerbatim}
A random integer in [1,100]: 96
\end{escapeRspVerbatim}
The filename of the output is the same as the RSP file with the file extension dropped.
%
To try this example yourself, do
\begin{verbatim}
path <- system.file("exData", package="R.rsp")
rfile("random.txt.rsp", path=path)
\end{verbatim}
%
To process the same RSP file into a string (without generating a file), do
\begin{verbatim}
path <- system.file("exData", package="R.rsp")
s <- rstring(file="random.txt.rsp", path=path)
cat(s)
\end{verbatim}
The latter example illustrates how \code{rstring()} also can load strings from either a file (or a URL or a connection) as an alternative to taking plain strings as input.



\subsection{Automatic postprocessing}
For RSP documents that outputs certain file formats such as LaTeX, Sweave, and knitr further processing of the RSP file output is often necessary before obtaining the final RSP product, e.g. a PDF file.
The \code{rfile()} function will, based on the content type of the generated RSP output, detected if further processing ("postprocessing") is possible.  If so, it is postprocessed to arrive at the final product.
For instance, consider an RSP-embedded LaTeX document \code{report.tex.rsp}.  When compiling it by
\begin{verbatim}
> rfile("report.tex.rsp")
\end{verbatim}
the \code{rfile()} method will
(i) parse and evaluate the RSP-embedded LaTeX document resulting in a LaTeX document (\code{report.tex}), but in addition it will also
(ii) compile the LaTeX document into a PDF (\code{report.pdf}).
To disable RSP postprocessing, specify argument \code{postprocess=FALSE} when calling \code{rfile()}.
%
To try postprocessing yourself, you can compile this very document by
\begin{verbatim}
> path <- system.file("doc", package="R.rsp")
> rfile("Dynamic_LaTeX_reports_with_RSP.tex.rsp", path=path)
\end{verbatim}
The generated PDF (\code{Dynamic\_LaTeX\_reports\_with\_RSP.pdf}) will be available in the current directory of R (see \code{getwd()}).
%
It is even possible to compile online RSP documents, e.g.
\begin{verbatim}
> url <- "http://r-forge.r-project.org/scm/viewvc.php/*checkout*/pkg/R.rsp/inst/doc/
          Dynamic_document_creation_using_RSP.tex.rsp?root=r-dots"
> rfile(url)
\end{verbatim}
which produces a PDF of the current developer's version of this vignette.




<%-------------------------------------------------------------------
  THE RSP MARKUP LANGUAGE
  -------------------------------------------------------------------%>
\section{The RSP markup language}
\label{RspMarkupLanguage}
An \emph{RSP-embedded text document}, or short an \emph{RSP document},
is a text document (string or file) that contains a set of
\emph{RSP constructs}, which each is defined by a pair of 
RSP start (\code{<\%}) and end (\code{\%>}) tags.
There are three types of RSP constructs:
\begin{enumerate}
 \item \emph{RSP comments} (\code{<\%--...--\%>}), 
 \item \emph{RSP code expressions} (\code{<\%...\%>}), and
 \item \emph{RSP preprocessing directives} (\code{<\%@...\%>}).
\end{enumerate}
Everything outside of RSP constructs is referred to as \emph{RSP text}.  Except from RSP comments, RSP constructs must not be nested or contain other constructs.
%
When an RSP document is \emph{evaluated} ("compiled"), it is first (i) \emph{parsed} where comments are dropped and preprocessing directives are processed, then (ii) \emph{translated} into plain R code, which when (iii) evaluated generates an \emph{RSP product} (as a string or an output file).

The simplest RSP document possible is a string that contains none of the above RSP constructs, just a single RSP text, which will be outputted "as is"\footnote{Except for escaped RSP start and end tags as explained in Section~\ref{RspEscape}.} in the outputted RSP product.
%
A slightly more ellaborate example is the RSP string
\begin{rspVerbatim}
"A random integer in [1,100]: <\%=sample(1:100, size=1)\%>{\bs}n"
\end{rspVerbatim}
is parsed by the RSP parser into the following sequence of RSP constructs:
(i) RSP text '\code{A random integer in [1,100]: }', 
(ii) RSP code expression '\code{<\%=sample(1:100, size=1)\%>}', and
(iii) RSP text '\code{{\bs}n}'.
When this sequence is later evaluated, the two RSP texts are inserted into the RSP product "as is", whereas for the RSP code expression its contained R code is evaluated and its return value is then inserted into the RSP product as text.
%

\subsection{RSP code expressions (\code{<\%...\%>})}
\label{RspCodeExpressions}


\subsubsection{Inlining values of variables and expressions (\code{<\%=\{code chunk\}\%>})}
\label{RspCodeChunkInlining}

The RSP markup \code{<\%=\{code chunk\}\%>} evaluates the code chunk\footnote{\code{\{code chunk\}} must be a complete and valid R expression, because \code{evalCapture()} is a function call.} (without inserting it into the document) and inserts the character representation\footnote{The \emph{character representation} of an object \code{x} is what \code{as.character(x)} gives.} of the returned object.  For instance,
\begin{rspVerbatim}
Today's date is <\%=Sys.Date()\%>
\end{rspVerbatim}
would produce the string 'Today's date is <%=Sys.Date()%>'.
If inlining a vector of values, they are all pasted together without a separator.  For example,
\begin{rspVerbatim}
The letters of the alphabet are '<\%=LETTERS\%>'
\end{rspVerbatim}
produces 'The letters the alphabet are '<%=LETTERS%>'.
To separate the elements with commas, use \code{<\%=paste(LETTERS, collapse=", ")\%>}.  Alternatively, use \code{<\%=hpaste(LETTERS)\%>} to output '<%=hpaste(LETTERS)%>'\footnote{The \code{hpaste()} function of \pkg{R.utils} provides "human-readable" pasting of vectors.}.


%% \clearpage
\subsubsection{Evaluating and capturing expression and output (\code{<\%=}\code{evalCapture}\code{(\{code chunk\})\%>})}
\label{RspCodeChunkCapture}
The \code{evalCapture()} function allows us to evaluate, embed and echo the text output of an R code chunk\footnote{\code{\{code chunk\}} must be a complete and valid code expression, because the expression is parsed and evaluated in place.}.  Note that it is only standard output that is echoed, i.e. plots are \emph{not} automatically embedded as figures.  To include figures, see Section~\ref{WorkingWithFigures}.  
Continuing, any formatting of the capture has to be done in the format of the output document.  For instance, the following RSP-embedded LaTeX text
\begin{rspVerbatim}
{\textbackslash}begin\{verbatim\}
<\%=evalCapture(\{
for (kk in 1:3) \{
  printf("Iteration #%d{\bs}n", kk)
\}

print(Sys.time())
type <- "horse";  # Comments are dropped
type
\})%>
{\textbackslash}end\{verbatim\}
\end{rspVerbatim}
produces
\begin{verbatim}
<%=evalCapture({
for (kk in 1:3) {
  printf("Iteration #%d\n", kk)
}

print(Sys.time())
type <- "horse";  # Comments are dropped
type
})%>
\end{verbatim}
By adding arguments \code{code=FALSE} and/or \code{output=FALSE} to \code{evalCapture()} one can control whether the deparsed R source code and/or the output of each subexpression is captured or not.
Note that code is parsed and formatted by the R parser, meaning that indentation, empty lines, spacing and so on are \emph{not} preserved when echoing this way.  This is also why comments, semicolons and other R code constructs are dropped from the displayed code.


\subsubsection{Evaluating code (\code{<\%\{code\}\%>})}
\label{RspCode}
The RSP markup \code{<\%\{code\}\%>} evaluates the source code (without displaying it in the output document).  For instance,
\begin{rspVerbatim}
<\%
n <- 3;  # Comments are kept
type <- "horse"
%>
\end{rspVerbatim}
evaluates the code such that \code{n == 3} and \code{type == "horse"} afterward.
Note that with this construct it is possible to insert incomplete code expression and completed it in a later RSP code block.  For example,
\begin{rspVerbatim}
Counting:<\% for (i in 1:3) \{ \%> <\%=ii\%><\% \} \%>.
\end{rspVerbatim}
For more details, see Section~\ref{MixtureOfRSPAndTextBlocks}.


\subsubsection{Evaluating and embedding code verbatim (\code{<\%:\{code\}\%>})}
\label{RspCodeEmbed}
Just as \code{<\%\{code\}\%>}, the RSP markup \code{<\%:\{code\}\%>} also evaluates source code (also incomplete code expressions), but in addition it also inserts the code verbatim into the document.  For instance,
\begin{rspVerbatim}
<\%:
n <- 3;  # A comment
type <- "horse"
%>
\end{rspVerbatim}
evaluates the code and insert the following into the output document
\begin{verbatim}
<%:
n <- 3;  # A comment
type <- "horse"
%>
\end{verbatim}
Note that with this construct it is \emph{not} possible the capture the \emph{output}, only the source code.


\subsubsection{Iterating over a mixture of RSP and text blocks}
\label{MixtureOfRSPAndTextBlocks}
A useful feature of RSP is that it is possible to use RSP constructs that span multiple code and text blocks.  For instance, the following will iterate over a set of text and code blocks
\begin{rspVerbatim}
The <\%=n <- length(letters)%> letters in the English alphabet are: 
<\% for (i in 1:n) \{ \%>
  <\%=letters[i]\%>/<\%=LETTERS[i]\%><\%=if(i < n) ", "\%>
<\% \} \%>.
\end{rspVerbatim}
which generates\footnote{Of course, in this particular case, the above for-loop can be replaced by \code{<\%=paste(letters, LETTERS, sep="/", collapse=", ")\%>}.}: 'The <%=n <- length(letters)%> letters in the English alphabet are: 
<% for (i in 1:n) { %>
  <%=letters[i]%>/<%=LETTERS[i]%><%=if(i < n) ", "%>
<% } %>.'\\

A more complex example is where one wish to generate a report on human genomic data across all of the 24 chromosomes and where the same type of analysis should be repeated for each chromosome.  With RSP markup, this can be achieved by an outer loop over chromosomes, as illustrated by
\begin{rspVerbatim}
<\% for (chromosome in 1:24) \{ %>
{\bs}section\{Chromosome <\%=chromosome\%>\}
...
A mix of RSP and text blocks constituting 
the analysis of the current chromosome.
...
<\% \} # for (chromosome ...) \%>
\end{rspVerbatim}

Note that there exist no corresponding markup in Sweave.  Instead, contrary to RSP, Sweave requires that each of the code chunks contains a complete R expression.  This means that, in terms of the above example, in Sweave it is not possible to begin a for loop in one code chunk and end it in a succeeding one.  This has to do with the fundamentally different way RSP and Sweave documents are processed.  If using Sweave, one solution is to use RSP markup in the Sweave document, process it via RSP to generate a pure Sweave document, which can then in turn be processed using the Sweave engine to get a TeX file and eventually the final PDF document.  Alternatively, one can use \code{rfile()} to complete all these steps at once, e.g. \code{rfile("report.Rnw.rsp")} will generate \code{report.pdf} as well as the intermediate \code{report.Rnw} and \code{report.pdf} files.  This illustrates the power of the RSP language and how it can be used as a preprocessor of any other literate programming language.


\subsubsection{Templates - reusing a mixture of RSP and text blocks}
Sometimes rather similar paragraphs of text, tables, or figures are used throughout a document with only minor differences.  Instead of manually cut'n'pasting the same pieces to other places of the document over and over, it is more robust and much easier to setup a template function which can then used in place.

Because of the nature of the RSP language, setting up a template is as simple as wrapping the mixture of RSP and code blocks (Section~\ref{MixtureOfRSPAndTextBlocks}) in a function definition.  For example, assume you wish to reuse the following RSP passage multiple times with different values of \code{n} in a LaTeX document
\begin{rspVerbatim}
The sum of $x=<\%=hpaste(1:n, abbreviate="{\bs}{\bs}ldots")\%>$ is <\%=sum(1:n)\%>.
\end{rspVerbatim}
The solution is to wrap it up in a \emph{template} function
\begin{rspVerbatim}
<\% myTemplate <- function(n, ...) \{ \%>
The sum of $x=<\%=hpaste(1:n, abbreviate="{\bs}{\bs}ldots")\%>$ is <\%=sum(1:n)-\%>.<\%-\%>
<\% \} # myTemplate() \%>
\end{rspVerbatim}
<% myTemplate <- function(n, ...) { %>
The sum of $x=<%=hpaste(1:n, abbreviate="\\ldots")%>$ is <%=sum(1:n)%>.<%-%>
<% } # myTemplate() %><%-- TO FIX: Should not be needed! /HB 2011-03-31 --%>
Recall that there is no limitation in how many text and RSP blocks you can use.
Note also how we use an empty RSP comment (\code{<\%-\%>}) at the end of the template function.  That is used in order to escape the trailing line break (Section~\ref{RspComments}).  Without the trailing RSP comment, the final document would contain a whitespace after the period (and before the closing single-quote in the previous sentence).
The above template function can now be used by calling it within an RSP code block as
\begin{rspVerbatim}
<\% myTemplate(n=3) \%>
\end{rspVerbatim}
which produces '<% myTemplate(n=3) %>'.
%
Naturally, a template function can be reused any number of times.  For example, the following RSP-embedded LaTeX block
\begin{rspVerbatim}
{\bs}begin\{itemize\}
<\% for (ii in c(3,5,10,100)) \{ \%>
 {\bs}item <\% myTemplate(n=ii) \%>
<\% \} # for (ii ...) \%>
{\bs}end\{itemize\}
\end{rspVerbatim}
produces
\begin{itemize}
<% for (ii in c(3,5,10,100)) { %>
 \item <%= myTemplate(ii) %>
<% } # for (ii ...) %>
\end{itemize}



\subsection{Trimming whitespace for RSP constructs}
\label{TrimmingWhitespace}
Because of readability of the RSP source document, RSP constructors are often placed on separate lines than the text blocks but also other RSP constructs.  Depending on how whitespace and line breaks (as introduced by the above coding style) are handled in the output format, this may or may not affect how the output document renders.  For instance, line breaks explicitly introduced in an RSP source document will make the an outputted plain text document look different whereas single line breaks will not affect how a LaTeX document is compiled.


\subsubsection{Trimming of lines with only non-text RSP constructs}
The whitespace before and after RSP constructs that are on their own lines without no other non-whitespace text will \emph{always} have their surround whitespace trimmed off.  They will also have the first following line break removed, unless it is manually controlled as describe in the next subsection.  This automatic trimming of "stand-alone" RSP constructs enhanced readability of RSP source documents without introducing unnecessary whitespace and line breaks.  Consider the following example and think about how whitespace and line breaks are removed or kept:
\begin{rspVerbatim}
You don't have to worry too much about whitespace, e.g. the
  <\%
     s <- "will have its surrounding whitespace"
  \%>
above RSP expression <\%=s\%>
trimmed off as well as its trailing line break.
\end{rspVerbatim}
which produces
\begin{verbatim}
You don't have to worry too much about whitespace, e.g. the
  <%
     s <- "will have its surrounding whitespace"
  %>
above RSP expression <%=s%>
trimmed off as well as its trailing line break.
\end{verbatim}


\subsubsection{Manually controlling trailing whitespace and line breaks}
Also for RSP constructs that are not surrounded by only whitespace, it is possible to control how whitespace and line breaks following RSP constructs are trimmed.  By adding a so called "suffix hyphen" at the end of an RSP construct, all following whitespace (space and tabs) including the first line break (the newline) is dropped ("trimmed"), if and only if there are no other characters following the RSP construct.  How this works is illustrated by the following three examples
\begin{escapeRspVerbatim}
> rstring("A random integer in [1,100]: <\%=sample(1:100, size=1)\%>{\bs}n")
[1] "A random integer in [1,100]: 48{\bs}n"
\end{escapeRspVerbatim}
to
\begin{escapeRspVerbatim}
> rstring("A random integer in [1,100]: <\%=sample(1:100, size=1)-\%>{\bs}n")
[1] "A random integer in [1,100]: 48"
\end{escapeRspVerbatim}
and
\begin{escapeRspVerbatim}
> rstring("A random integer in [1,100]: <\%=sample(1:100, size=1)-\%> {\bs}t {\bs}n{\bs}n{\bs}n")
[1] "A random integer in [1,100]: 48{\bs}n{\bs}n"
\end{escapeRspVerbatim}

Note that the above applies to all types of RSP constructs, including all existing RSP comments, a construct that introduced next.


\subsection{Comments (\code{<\%--\{anything\}--\%>})}
\label{RspComments}
The RSP markups \code{<\%--\{anything\}--\%>}, \code{<\%---\{anything\}---\%>} and so on\footnote{The number of prefix and suffix hyphens in an RSP comment must match, i.e. \code{<\%--- A comment --\%>} is \emph{not} recognized as an RSP comment.} represent RSP comments, which can be used to drop large sections of an RSP document\footnote{An RSP comment may can contain \emph{anything} because it is dropped by the RSP parser at the very beginning before parsing the text and the other RSP constructs.}.  Unlike other RSP constructs, an RSP comment may contain other RSP constructs (also incomplete ones) including RSP comments.  
In order to nest RSP comments, any nested comment must use a different number of hyphens compared to the surrounding RSP comment\footnote{The reason for needing a different number of hyphens in nested RSP comments is because RSP comments are \emph{non-greedy}, that is, anything between (and including) the \code{<\%--} and the \emph{first} following \code{--\%>} will be dropped.}.
For example, the following RSP document
\begin{rspVerbatim}
<\%-- This is an RSP comment that will be dropped --\%>
You can write a paragraph and drop a large portion of it using 
<\%--- This comment contains both regular RSP expressions 
There are <\%=n\%> red <\%=type\%>s 
<\%-- as well as another RSP comment --\%>
which is nested. ---\%> RSP comments.
\end{rspVerbatim}
is from the parser's point of view equivalent to the following RSP document
\begin{rspVerbatim}
You can write a paragraph and drop a large portion of it using 
RSP comments.
\end{rspVerbatim}
which produces
\begin{verbatim}
<%-- This is an RSP comment that will be dropped --%>
You can write a paragraph and drop a large portion of it using 
<%--- This comment contains both regular RSP expressions 
There are <%=n%> red <%=type%>s 
<%-- as well as another RSP comment --%>
which is nested. ---%> RSP comments.
\end{verbatim}

As explained in Section~\ref{TrimmingWhitespace}, \emph{all} RSP constructs with a suffix hyphen causes any following whitespace including the first following line break to be trimmed, if no other characters appear after the contruct.  This means that all RSP comments automatically trims such empty text.
This explains why there are no empty lines after dropping the RSP comments in the above example.
Further more, note that trailing whitespace can be trimmed from any line by adding \code{<\%----\%>} at the end of that line.  For convenience, one can also use \code{<\%-\%>}, which is a short form for \code{<\%----\%>}.


\subsection{Escaping RSP start and end tags (\code{<\%\%} and \code{\%\%>})}
\label{RspEscape}
To include '\code{<\%}' and '\code{\%>}' in the text of the RSP product
they need to be escaped so that the RSP parser does not recognize them as
being part of an RSP construct.  This can be done as '\code{<\%\%}' and
'\code{\%\%>}', respectively.  For instance,
\begin{escapeRspVerbatim}
> rcat("A random integer in [1,100]: <\%\%=sample(1:100, size=1)\%\%>{\bs}n")
A random integer in [1,100]: <\%=sample(1:100, size=1)\%>
\end{escapeRspVerbatim}
To clarify this further, consider the output of the following steps
\begin{escapeRspVerbatim}
> a <- "A random integer in [1,100]: <\%\%=sample(1:100, size=1)\%\%>{\bs}n"
> b <- rstring(a)
> rcat(b)
A random integer in [1,100]: 8
\end{escapeRspVerbatim}




<%-------------------------------------------------------------------
  ADDITIONAL FEATURES
  -------------------------------------------------------------------%>

<%-------------------------------------------------------------------
  PREPROCESSING DIRECTIVES
  -------------------------------------------------------------------%>
\subsection{Preprocessing directives (\code{<\%@...\%>})}
\label{PreprocessingDirectives}
An \emph{RSP preprocessing directive}, or short an \emph{RSP directive}, is an RSP construct that starts with an '\code{@}' followed by a \emph{directive} and zero or more \emph{named arguments}, e.g. \code{<\%@include file="random.tex.rsp"\%>}.    RSP directives can for instance be used to include the content of another file or conditionally include/exclude parts of the existing document.  RSP preprocessing directives facilitates modularizing RSP documents such that the same RSP module can be reused in many places, which in turn minimizes and often eliminates the manual and often error-prone process of cut-and-pasting content between documents.

The formal syntax for an RSP preprocessing directive is \code{<\%@\{directive\} [\{name\}="\{value\}"]*\%>}.
RSP preprocessing directives are processed during the parsing of the RSP document.  This is done \emph{after} RSP comments have been dropped and \emph{before} RSP code expressions are parsed.  This means that:
\begin{itemize}
 \item RSP comments can be used to commenting out and hence exclude RSP preprocessing directives, e.g. \code{<\%--- <\%@include file=\lb"random.tex.rsp"\%> ---\%>}.
 \item RSP preprocessing directives may insert new RSP code expressions as if they where part of the original RSP document, e.g. \code{<\%@include file="random.tex.rsp"\%>}.  Any RSP comments inserted will be dropped as expected.  If other RSP directives are inserted, they are processed immediately.
 \item After being processed, only RSP text and RSP code expressions remains (no RSP preprocessing directives).   Notably, RSP code expression \emph{does not see or have access} to RSP preprocessing directives or any of their assigned variables.
\end{itemize}

Just like RSP comments, RSP directives are designed to be independent of the programming language.  In other words, by design these constructs are not relying on the R language.  Another way look at it is that the processing of RSP comments and RSP directives may be done by an \emph{RSP processor} written in a different language than R, e.g. Python or C.

<%----
When an RSP-embedded document in processed, it is (i) \emph{parsed}, (ii) \emph{preprocessed}, (iii) \emph{translated} to R source code, which is then (iv) \emph{parsed and evaluated} by the R engine.  It is during this last step the RSP document is outputted (as a file or as a character string).
During the initial parsing, RSP comments and their contents are dropped.
During preprocessing, RSP \emph{preprocessing directives}, which are RSP constructors of format \code{<\%@...\%>}, are processed.
Such directives can be used to for instance programmatically control how parts of an RSP document are included or excluded based on some conditions or they can be used to include an external RSP source into the main RSP document.
Although the afformentioned maybe achieved with by plain R \code{<\%~...~\%>} constructs, these tasks are much bettered handled by RSP preprocessing directives.  It is also useful to understand that preprocessing directives are RSP constructs that are \emph{independent of the R language} per se and are processed before the RSP document is interpreted as R source code\footnote{Conceptually, there is nothing preventing an RSP document to be parsed and preprocessed by another implementation in a different programming language than R.  It is only the succeeding steps that are specific to the R language.}.
After preprocessing, there are no remaining RSP preprocessing directives left in the RSP document, which then only contains text and basic RSP constructs (Sections~\ref{RspCodeChunkInlining}-\ref{RspCodeEmbed}).
----%>

All RSP directive arguments (also known as "attributes") must be named with names having the correct case and not being abbreviated.  For instance, \code{<\%@include file=\lb"random.tex.rsp"\%>} is correct whereas \code{<\%@include "random.tex.rsp"\%>}, \code{<\%@include Language=\lb"random.tex.rsp"\%>} and \code{<\%@include lang=\lb"random.tex.rsp"\%>} are not.
%
The value of an RSP directive argument is parsed as a \emph{GString}\footnote{In R, GString can be processed by the \code{gstring()} function in the \pkg{R.utils} package.}.  A GString is a regular string that optionally may contain bash-like syntax for inserting values of system environment variables.  For instance, if the environment variable '\code{R\_HOME}' is set to the home directory of the R installation, then \code{<\%@include file=\lb"\$\{R\_HOME\}/doc/AUTHORS"\%>} is parsed as \code{<\%@include file=\lb"/path/to/R/doc/AUTHORS"\%>} (resulting in the content of that 'AUTHORS' file to be included "as is").  Note how this substitution is indepent of the R language.
For conveniency, when processing an RSP document using the RSP parser of the \pkg{R.rsp} package, GString also looks for a matching variables elsewhere.  Notably, it searches (i) among the variables in the R workspace, (ii) among the R options, and then (iii) among the system environment variable.\footnote{Although the RSP parser of the \pkg{R.rsp} package also looks for GString variable in the R environment and its options, it does not mean that these variables are dependent on the R language.  The substituted value will always be interpreted as a character string.  An RSP parser implemented in Python could take a similar approach}
Importantly, note that variables set in RSP code expressions \emph{cannot} be used in RSP directives, because they are only assigned after the RSP preprocessing directives have been processed.

\subsubsection{Including text and RSP contents}
It is possible to include the contents of other text and RSP documents.  These can be either specified as strings (argument '\code{text}') or as files (argument '\code{file}'), which may be either a file on the file system or URL/document online.
All contents included is considered to have a certain \emph{language} attribute.   The language attribute specifies how the content is included in the document.  For instance, plain text has language attribute 'text' and is included "as is"\footnote{RSP start and end tags in plain text are escaped before being included.  How to escape in RSP, see Section~\ref{RspEscape}.}.
An RSP document has language attribute 'rsp', and is included in the main RSP document as an parsed RSP document.
The default is to infer the language attribute automatically, e.g. from the filename extension of the \code{file} argument.  When this is not possible, it may be necessary to specify the '\code{language}' argument, e.g. \code{language="text"}.

\paragraph{Including plain text (\code{<\%@include text="\{text\}"\%>})}
Although not commonly needed, it is possible to include plain text during the preprocessing of the RSP document.  For example, the template RSP document
\begin{rspVerbatim}
The \code{R_HOME} environment variable was '<\%@include text="${R_HOME}"\%>'
at the time when this document was preprocessed.
\end{rspVerbatim}
results in an preprocessed RSP document consisting of
\begin{rspVerbatim}
The \code{R_HOME} environment variable was '<%@include text="${R_HOME}"%>'
at the time when this document was preprocessed.
\end{rspVerbatim}
Whenever using the '\code{text}' argument, the 'language' attribute is assumed to be 'text'.

<%---
  To include a parsed RSP string, one need to specify the 'language' attribute as:
\begin{rspVerbatim}
<\%@include text="Current time is '<\%=Sys.time()\%>'." language="rsp"\%>
at the time this document was preprocessed.
\end{rspVerbatim}
results in an preprocessed RSP document consisting of
\begin{rspVerbatim}
<%@include text="Current time is '<%=Sys.time()%>'." language="rsp"%>
\end{rspVerbatim}
---%>


\paragraph{Including file contents (\code{<\%@include file="\{pathname\}"\%>})}
To include the content of a text file "as is" during preprocessing, use the '\code{file}' argument.  This may be used to include a local file or a file online (specified as a URL).  For instance,
\begin{rspVerbatim}
... '<\%@include file="randoms.txt"\%>'  ## <== Update
\end{rspVerbatim}
To include the RSP parsed content of a text file with RSP markup, do
\begin{rspVerbatim}
... '<\%@include file="randoms.txt.rsp"\%>'  ## <== Update
\end{rspVerbatim}
The 'language' attribute, which specifies how the content is included, is by default inferred from the filename extension of the included filename.  If the extension (in lower case) is '\code{txt}', the language is assumed to be 'text'.  If it is '\code{rsp}', then the language is assumed to be 'rsp'.  For unknown extensions, it is always assumed to be 'text'.  The 'language' attribute can be specified using the '\code{language}' argument.

File content that is included as 'text' language will be included "as is", except that RSP start and end tags are escaped such that they appear verbatim in the final RSP product.  For instance, consider the difference between the following two include statements:
\begin{escapeRspVerbatim}
> cat("<\%=Sys.time()\%>", file="time.txt.rsp")
> rcat('The current time is <\%@include file="time.txt.rsp"\%>.{\bs}n')
The current time is <%=Sys.time()%>.
> rcat('The current time is <\%@include file="time.txt.rsp" language="text"\%>.{\bs}')
The current time is <\%=Sys.time()\%>.
\end{escapeRspVerbatim}

Be careful not to include the same file recursively over and over as the following case would do:
\begin{escapeRspVerbatim}
> cat('Recursive <\%@include file="endless.txt.rsp"\%>', file="endless.txt.rsp")
> rcat(file="endless.txt.rsp")
\end{escapeRspVerbatim}
The RSP parser implemented in the \pkg{R.rsp} package will give an error if it detects file inclusions that are nested too deeply.


\emph{To be continued.}


\subsubsection{Conditional inclusion/exclusion}
\emph{To be documented.}

\paragraph{If equal to, else, end if (\code{<\%@ifeq var="\{value\}"\%>})}
\emph{To be continued.}

\paragraph{If not equal to, else, end if (\code{<\%@ifneq var="\{value\}"\%>})}
\emph{To be continued.}



\subsubsection{RSP document annotation}

\paragraph{Setting type, title and more (\code{<\%@page type="{type}" ...\%>})}
\emph{To be continued.}

\paragraph{Including the title (\code{<\%@title\%>})}
\emph{To be continued.}

\paragraph{Including the keywords (\code{<\%@keywords\%>})}
\emph{To be continued.}

\paragraph{Setting title and keywords via R vignette directives}
 (\code{<\%\@eval language="R-vignette"\%>})
\emph{To be continued.}


\subsubsection{Preprocessing variables and code evaluation}

\paragraph{Defining variable (\code{<\%@define var="\{value\}"\%>})}
\emph{To be continued.}

\paragraph{Evaluating R code (\code{<\%@eval language="R" ...\%>})}
\emph{To be continued.}

\paragraph{Evaluating R vignette directives (\code{<\%@eval language="R-vignette" ...\%>})}
\emph{To be continued.}

\paragraph{Evaluating system call (\code{<\%@eval language="system" ...\%>})}
\emph{To be continued.}





\subsubsection{Compiling a standalone RSP document
from a preprocessed but not evaluated RSP document template}
However convenient it is to use a modularized RSP document that reuses many different RSP subdocuments, it may be tedious to share such as document with others.  In order for someone else to compile the same RSP document, it is necessary to make sure all files being used are also shared with the receiver together with instructions where to put them.  Some of these files may only be included under certain conditions, making the just add to the overall clutter at the receiver's end.
 In such cases, it may be useful to produce \emph{a preprocessed but not yet evaluated RSP document} from the main RSP document.  Such an RSP document will not contain any preprocessing directives and in that sense be self-contained and easier to share.  It is also likely be easier for the reciever to follow.
To compile such a stand-alone RSP document, do:
\begin{escapeRspVerbatim}
> rcompile("random.txt.rsp") ## <= Not yet implemented in R.rsp!
\end{escapeRspVerbatim}
This outputs a file \code{preprocessed-random.txt.rsp} in the current directory.
Documents compiled this way will contain neither RSP comments nor RSP preprocessing directives.  This may be useful if the source RSP subdocuments contain private comments and private parts that are conditional excluded during preprocessing.



<%-------------------------------------------------------------------
  FIGURES
  -------------------------------------------------------------------%>
\section{Working with figures}
\label{WorkingWithFigures}
Because the RSP language is context unaware, it does not have constructs for inserting content such as figures and tables.  However, as we will show in this section, it is still very easy to create and include figures in the output document.
We will first explain how to create image files and then show how they can be included in LaTeX, Markdown and HTML documents in a standard and unified way.


\subsection{Creating image files}
The \code{toPDF()} and \code{toPNG()} functions of the \pkg{R.devices} package\footnote{The \pkg{R.devices} package is automatically loaded when \pkg{R.rsp} is loaded.} are useful for creating image files to be included in for instance LaTeX and HTML.  For example,
\begin{verbatim}
# Use greater objects by default
setOption("devNew/args/par", list(lwd=2));

toPDF("myFigure,yeah,cool", aspectRatio=0.6, { 
  curve(dnorm, from=-5, to=+5)
})
\end{verbatim}
creates a PDF image file named \code{myFigure,yeah,cool.png} whose height is 60\% of its width and displays the Guassian density distribution.
By default, the \code{toPDF()} and \code{toPNG()} functions write image files to the \code{figures/} directory.  For more information, see \code{help("toPDF")}.


\subsection{Including image files in LaTeX}
When inserting a figure in LaTeX, it is recommended to do so without specifying neither the path nor the filename extension of the image file when including the image, e.g. \code{{\textbackslash}includegraphics\{MyFigure\}}.
In order for this to work, one must specify the "image search path" in LaTeX, e.g.
\begin{verbatim}
\graphicspath{{figures/}{figures/external/}}
\end{verbatim}
which is preferably added to the beginning of the LaTeX document.  This tells LaTeX to search for image files in directory \code{figures/} as well as directory \code{figures/external/}.   Moreover, by leaving out the filename extension, LaTeX will automatically search\footnote{In order for \code{{\bs}includegraphics\{\}} to locate a proper image files when leaving out the filename extension, the image file must not have other periods in the filename other than the one used for the extension.} for image files with different filename extensions, e.g. \code{*.png} and \code{*.pdf}.
%
\begin{figure}[htp]
 \begin{center}
 \resizebox{0.70\textwidth}{!}{%
  \includegraphics{<%=toPDF("MyFigure,yeah,cool", aspectRatio=0.6, {
   curve(dnorm, from=-5, to=+5);
  })%>}
 }%
 \end{center}
 \caption{This figure was generated and inserted into the LaTeX document using RSP.}
 \label{fig:MyFigure}
\end{figure}
%
With this setup, it is possible to create and embed a figure as the one in Figure~\ref{fig:MyFigure} using the following tidy RSP and LaTeX markup\footnote{For readability, we have dropped the usual LaTeX commands for setting up the \code{figure} environment, centering and rescaling the image and creating the figure caption.}%
\begin{rspVerbatim}
{\bs}includegraphics\{<\%=toPDF("MyFigure,yeah,cool", aspectRatio=0.6, \{
  curve(dnorm, from=-5, to=+5);
\})\%>\}
\end{rspVerbatim}
After the RSP code has been processed, and the image file has been created, the above simply produces the following LaTeX block in the generated LaTeX document:
\begin{verbatim}
\includegraphics{MyFigure,yeah,cool}
\end{verbatim}
The reason for the latter is that by default \code{toPDF()} and \code{toPNG()} return the filename of the created image file without its directory and without its filename extension, i.e. \code{"myFigure,yeah,cool"}.
As a final remark, note that by replacing \code{toPDF()} with \code{toPNG()}, a PNG image file is inserted instead, which can dramatically reduce the size of the final PDF document, especially when scatter plots with a large number of data points are generated.


\subsection{Including image files in HTML}
An image file is included in an HTML document via its pathname.  To have \code{toPNG()}, \code{toSVG()} and so on, return the (relative) pathname of files created, add the following to the top of your RSP document:
\begin{rspVerbatim}
<\%
setOption("devEval/args/field", "pathname")
\%>
\end{rspVerbatim}
With this setting, one can then include PNG image files in the HTML document as
\begin{rspVerbatim}
<img src="<\%=toPNG("MyFigure,yeah,cool", aspectRatio=0.6, \{
  curve(dnorm, from=-5, to=+5);
\})\%>">
\end{rspVerbatim}
which results in
\begin{verbatim}
<img src="figures/MyFigure,yeah,cool.png">
\end{verbatim}


\subsection{Including image files in Markdown}
Just as for HTML documents, on need to set the option that images created by \code{toPNG()} etc are returned by their (relative) pathnames by specifying option \code{devEval/args/field} (see above subsection).  With this setting, one can then include PNG image files in the Markdown document as
\begin{rspVerbatim}
![This figure was generated and inserted into the Markdown document using RSP.]
(<\%=toPNG("MyFigure,yeah,cool", aspectRatio=0.6, \{
  curve(dnorm, from=-5, to=+5);
\})\%>)
\end{rspVerbatim}
which results in
\begin{verbatim}
![This figure was generated and inserted into the Markdown document using RSP.]
(figures/MyFigure,yeah,cool.png)
\end{verbatim}





<%@ifeq docVersion = "devel"%>
<%-------------------------------------------------------------------
  RSP-EMBEDDED SWEAVE DOCUMENTS
  -------------------------------------------------------------------%>
\section{RSP-embedded Sweave documents}
We advocate using RSP over Sweave, because of its richness and generality to the underlying document format.  However, for Sweave users, we will in this section show how to enhance Sweave with RSP-embedded markup to circumvent a few of Sweave's shortcomes.


\subsection{Programmatically setting Sweave code chunk options}

In the R-help thread 'sweave options with variable' on 2011-04-17, it was asked if it is possible to use a variable to control the 'eval' option of a code chunk, e.g. \code{<<eval=needRun>>=} instead of \code{<<eval=TRUE>>=} or \code{<<eval=FALSE>>=}.  As explained in the thread, this is not possible to do in plain Sweave, but using RSP it is straightforward:
\begin{rspVerbatim}
<\% needRun <- TRUE \%>
<<eval=<\%=needRun\%>>>=
someSlowFunction()
@
\end{rspVerbatim}
Without RSP the following workaround will achieve the same effect:
\begin{verbatim}
<<echo=FALSE>>=
needRun <- TRUE
@

...

<<thecode,eval=FALSE>>=
someSlowFunction()
@

<<echo=FALSE>>=
if (needRun) {
<<thecode>>
}
@
\end{verbatim}


\subsection{Iterating over a mixture of code and text blocks}
As mention above, it is not possible to programmatically loop over a mixture of text and code chunks in Sweave.  A workaround for this is to use RSP markup to define the loop.  For example, in Sweave the following\footnote{This example is taken from the Sweave User Manual part of the \pkg{utils} package.} does not work
\begin{verbatim}
<<fig=TRUE>>
for (i in 1:4) plot(rnorm(100)+i)
@
\end{verbatim}
With RSP, one can do
\begin{rspVerbatim}
<\% for (kk in 1:4) \{ \%>
<<fig=TRUE, echo=FALSE>>=
  i <- <\%=kk\%>  <\%-- NOTE: Sweave does not see RSP variables! --\%>
  plot(rnorm(100)+i)
@
<\% \} # for (kk ...) \%>
\end{rspVerbatim}
This will expand to four \code{<<fig=TRUE, echo=FALSE>>=\,[...]\,@} chunks before Sweave sees it.
Alternative, one might want to use an \emph{RSP template} to tidy it up further, e.g.
\begin{rspVerbatim}
<\% mySweaveFigure <- function(kk, ...) \{ \%>
<<fig=TRUE, echo=FALSE>>=
  i <- <\%=kk\%>  <\%-- NOTE: Sweave does not see RSP variables! --\%>
  plot(rnorm(100)+i)
@
<\% \} # mySweaveFigure() \%>
\end{rspVerbatim}
and then generate the four Sweave figure chunks by
\begin{rspVerbatim}
<\% for (kk in 1:4) \{ mySweaveFigure(kk) \} \%>
\end{rspVerbatim}


Without RSP, the workaround is to manually generate the image files and have the code output the correct LaTeX commands much like one would do without Sweave, e.g.
\begin{verbatim}
<<results=tex,echo=FALSE>>=
for (i in 1:4) {
  fn <- paste("myfile", i, ".pdf", sep="")
  pdf(file=fn, width=6, height=6)
  plot(rnorm(100)+i)
  dev.off()
  cat("\\includegraphics{", fn, "}\n\n", sep = "")
}
@
\end{verbatim}
This latter approach is error prone, especially because of how the LaTeX code has to be escaped and generated using R code.
<%@endif%> <%-- docVersion --%>


<%@ifeq docVersion = "devel"%>
<%-------------------------------------------------------------------
  COMPARISON TO OTHER METHODS
  -------------------------------------------------------------------%>
\section{Brief comparison to other markup languages}

\begin{table}[htb]
\begin{center}
\begin{tabular}{lccc}
Feature & RSP & brew & Sweave \\
\hline
Context-independent processing                 & yes & yes &  - \\
Interweaving incomplete code and text snippets & yes & yes &  - \\
Preprocessing markup                           & yes &   - &  - \\
Markup comments                                & yes &   - &  - \\
Nested multiline markup comments               & yes &   ? &  - \\
"As-is" insertion of other files               & yes &   ? &  - \\
\hline
\end{tabular}
\end{center}
\caption{Comparison of features in different R-related markup languages.}
\end{table}
<%@endif%> <%-- docVersion --%>


<%-------------------------------------------------------------------
  APPENDIX
  -------------------------------------------------------------------%>
\clearpage
\section*{Appendix}
\subsection*{Session information}
<%=toLatex(sessionInfo())%>
This report was automatically generated using \code{rfile()} of the R.rsp package.
Total processing time after RSP-to-R translation was <%=dt <- round(Sys.time()-t0, digits=2)%> <%=attr(dt, "units")%>.

\end{document}
