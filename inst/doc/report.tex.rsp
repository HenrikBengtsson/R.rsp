<% t0 <- Sys.time() %>

<%--
<%
setOption("R.rsp/vignettes/docMode", "slides");
setOption("R.rsp/vignettes/docVersion", "devel");
%>
<%----%>

<%-------------------------------------------------------------------
  ARTICLE OR SLIDES?
  -------------------------------------------------------------------%>
<%
docMode <- getOption("R.rsp/vignettes/docMode", "article");
docMode <- match.arg(docMode, choices=c("article", "slides"));
if (docMode == "article") {
  docOptions <- "letter,12pt";
} else if (docMode == "slides") {
  docOptions <- "a5paper,12pt,landscape";
}
%>


<%-------------------------------------------------------------------
  RELEASE OR DEVEL?
  -------------------------------------------------------------------%>
<%
docVersion <- getOption("R.rsp/vignettes/docVersion", "release");
docVersion <- match.arg(docVersion, choices=c("release", "devel"));
%>

\documentclass[<%=docOptions%>]{article}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{alltt}
\graphicspath{{figures/}}


<%-------------------------------------------------------------------
  DOCUMENT MODE SPECIFIC SETTINGS
  -------------------------------------------------------------------%>
<% if (docMode == "slides") { %>
% Adjust margins
\addtolength{\oddsidemargin}{-0.75in}	
\addtolength{\evensidemargin}{-0.75in}	
\addtolength{\textwidth}{1.5in}
\addtolength{\topmargin}{-1.3in}	
\addtolength{\textheight}{2.3in}

% Adjust the title to appear higher up
\usepackage{titling} % \droptitle
\setlength{\droptitle}{-9ex}

% Add a \clearpage before each \section{}
\makeatletter
\renewcommand{\section}{\@startsection
{section}
{1}
{0mm}
{-3.5ex \@plus -1ex \@minus -.2ex}
{2.3ex \@plus.2ex}
{\clearpage\normalfont\Large\bfseries}}
\makeatother

% Fonts
%%\usepackage{mathptmx}  % times roman, including math (where possible)
%%\usepackage{mathpazo}  % palatino, including math (where possible)
%% \usepackage{helvetica}    % helvetica
\renewcommand{\familydefault}{\sfdefault}
<% } else { %>
% Adjust margins
\addtolength{\oddsidemargin}{-0.5in}	
\addtolength{\evensidemargin}{-0.5in}	
\addtolength{\textwidth}{1in}
\addtolength{\topmargin}{-0.5in}	
\addtolength{\textheight}{1in}
<% } # if (docMode ...) %>



%% \setlength{\parindent}{0in} 
%% \setlength{\parskip}{\baselineskip}


\newcommand{\keywords}[1]{\footnotesize{\textbf{Keywords: }#1}\xspace}
\newcommand{\pkg}[1]{\textsl{#1}\xspace}
\newcommand{\code}[1]{\texttt{#1}\xspace}
\newcommand{\bs}{$\backslash$}

\newenvironment{rspVerbatim}{\vspace{-\parskip}\begin{alltt}\color{blue}}{\end{alltt}}
\newenvironment{escapeRspVerbatim}{\vspace{-\parskip}\begin{alltt}}{\end{alltt}}



<%
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Set default graphics options
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Use greater objects by default
setOption("devNew/args/par", list(lwd=2));

# Change the default dimensions for PNGs
devOptions("png", width=840)
%>


\title{Dynamic LaTeX reports with RSP<%=ifelse(docVersion == "devel", "*", "")%>}
\author{Henrik Bengtsson}
\date{<%=format(as.Date(getDate(R.rsp)), format="%B %d, %Y")%>}

\begin{document}

\maketitle
\begin{abstract}
An important part of a statistical analysis is to document the analysis and its results.  A common approach is to build up an R script as the the analysis progresses.  This script may generate image files and tables that are later inserted manually into a, say, LaTeX report.  This strategy works alright for small one-off analyzes, whereas for larger and partly repetitive analyzes an automatic report generator is more suitable.

In this document we will illustrate how a LaTeX document can be extended with the RSP markup language resulting in a very powerful tool for generating dynamic reports in R.  
As we will discover, with RSP it is possible to generate document constructs that are not possible in Sweave, e.g. looping of a mix of R and LaTeX blocks.
Because RSP is a so called \emph{context-indepent} markup language, RSP can be used to produce documents of any text-based format, e.g. plain text, HTML, XML, SVG, as well as Javascript, R, and Sweave.
This document was produced using RSP-embedded LaTeX.
\end{abstract}

\keywords{reproducible research, report generator, markup language, LaTeX}

\begin{center}
\emph{This document is under construction.}
\end{center}

\clearpage
\tableofcontents

\clearpage

<%-------------------------------------------------------------------
  INTRODUCTION
  -------------------------------------------------------------------%>
\section{Compiling RSP-markup documents}
In order to utilize the methods explained in this document, the \pkg{R.rsp} package\footnote{To install the \pkg{R.rsp} package, call \code{install.packages("R.rsp")} at the R prompt.} needs to be loaded, i.e. \code{library("R.rsp")}.
As a first example, consider the following RSP-embedded R string
\begin{rspVerbatim}
"A random number in [1,100]: <\%=sample(1:100, size=1)\%>{\bs}n"
\end{rspVerbatim}
It can be compiled as
\begin{escapeRspVerbatim}
> rsp(text="A random number in [1,100]: <\%=sample(1:100, size=1)\%>{\bs}n")
A random number in [1,100]: 77
\end{escapeRspVerbatim}


Any document with RSP markup can be compiled using the \code{rsp()} method.  
For instance, consider an RSP-embedded text file \code{README.txt.rsp}.  In order to compile it into a plain text file, do
\begin{verbatim}
rsp("README.txt.rsp")
\end{verbatim}
This will
(i) translate the RSP text file into a valid 
    R script (\code{README.txt.rsp.R}), and
(ii) run the R script resulting in a plain text file (\code{README.txt}).
Other document formats can be compiled in a similar way, e.g. \code{rsp("index.html.rsp")} and \code{rsp("report.Rnw.rsp")}.\\

For certain document formats recognized by \code{rsp()}, further processing will also be done.  For instance, consider a RSP-embedded LaTeX document \code{report.tex.rsp}.  When compiling it by
\begin{verbatim}
rsp("report.tex.rsp")
\end{verbatim}
the \code{rsp()} method will as before
(i) translate the LaTeX RSP document into a valid 
    R script (\code{report.tex.rsp.R}), and
(ii) run the R script resulting in a LaTeX document (\code{report.tex}), but it will also
(iii) compile the LaTeX document into a PDF (\code{report.pdf}).
To try this yourself, compile this very document by calling
\begin{verbatim}
library("R.rsp")
path <- system.file("doc", package="R.rsp")
rsp("report.tex.rsp", path=path)
\end{verbatim}
The PDF (\code{report.pdf}) will be available in the current directory of R (see \code{getwd()}).\\



<%-------------------------------------------------------------------
  THE RSP MARKUP LANGUAGE
  -------------------------------------------------------------------%>
\section{The RSP markup language}

\subsection{Inlining values of variables (\code{<\%=\{code\}\%>})}
The RSP markup \code{<\%=\{code\}\%>} evaluates the code (without inserting it into the document) and inserts the character representation\footnote{The \emph{character representation} of an object \code{x} is what \code{as.character(x)} gives.} of the returned object.  For instance,
\begin{rspVerbatim}
Today's date is <\%=Sys.Date()\%>
\end{rspVerbatim}
would produce the string 'Today's date is <%=Sys.Date()%>'.
If inlining multiple values, they are all pasted together without any separator.  For example,
\begin{rspVerbatim}
The letters of the alphabet are '<\%=LETTERS\%>'
\end{rspVerbatim}
produces 'The letters the alphabet are '<%=LETTERS%>'.
To separate the elements with commas, use \code{<\%=paste(LETTERS, collapse=", ")\%>}.  Alternatively, use \code{<\%=hpaste(LETTERS)\%>} to output '<%=hpaste(LETTERS)%>'\footnote{The \code{hpaste()} function of \pkg{R.utils} provides "human-readable" pasting of vectors.}.


\subsection{Evaluating code (\code{<\%\{code\}\%>})}
The RSP markup \code{<\%\{code\}\%>} evaluates the code (without inserting it into the document).  For instance,
\begin{rspVerbatim}
<\%
n <- 3;  # Comments are kept
type <- "horse"
%>
\end{rspVerbatim}
evaluates the code such that \code{n == 3} and \code{type == "horse"} afterward.



%% \clearpage
\subsection{Capturing evaluated code (\code{<\%=evalCapture(\{code chunk\})\%>})}
The \code{evalCapture()} function allows us to evaluate, embed and echo the output of a code chunk\footnote{\code{\{code chunk\}} must be a complete and valid R expression, because \code{evalCapture()} is a function call.}. 
Formatting of the capture has to be taken care of by LaTeX.  Below we have explicitly wrapped the RSP markup inside a \code{{\textbackslash}begin\{verbatim\}...{\textbackslash}end\{verbatim\}} block.
For example,
\begin{rspVerbatim}
<\%=evalCapture(\{
for (kk in 1:3) \{
  printf("Iteration #%d{\bs}n", kk)
\}

print(Sys.time())
type <- "horse";  # Comments are dropped
type
\})%>
\end{rspVerbatim}
produces
\begin{verbatim}
<%=evalCapture({
for (kk in 1:3) {
  printf("Iteration #%d\n", kk)
}

print(Sys.time())
type <- "horse";  # Comments are dropped
type
})%>
\end{verbatim}
By adding arguments \code{code=FALSE} and/or \code{output=FALSE} one can control whether the deparsed source code and/or the output of each subexpression is captured or not.
Note that code is parsed and formatted by the R parser, meaning that indentation, empty lines, spacing and so on are \emph{not} preserved when echoing this way.  This is also why comments, semicolons and other code constructs are dropped from the code.


\subsection{Evaluating and embedding code verbatim (\code{<\%:\{code\}\%>})}
Just as \code{<\%\{code\}\%>}, the RSP markup \code{<\%:\{code\}\%>} also evaluates code, but in addition it also inserts the code verbatim into the document.  For instance,
\begin{rspVerbatim}
<\%:
n <- 3;  # A comment
type <- "horse"
%>
\end{rspVerbatim}
evaluates the code and insert the following into the output document:
\begin{verbatim}
<%:
n <- 3;  # A comment
type <- "horse"
%>
\end{verbatim}
Note that with this construct it is \emph{not} possible the capture the \emph{output}, only the code.




\subsection{Iterating over a mixture of RSP and text blocks}
A useful feature of RSP is that it is possible to use RSP constructs that span multiple code and text blocks.  For instance, the following will iterate over a set of text and RSP blocks:
\begin{rspVerbatim}
The <\%=n <- length(letters)%> letters in the English alphabet are: 
<\% for (i in 1:n) \{ \%>
  <\%=letters[i]\%>/<\%=LETTERS[i]\%><\%=if(i < n) ", "\%>
<\% \} \%>.
\end{rspVerbatim}
which generates:\footnote{Of course, in this particular case, the above for-loop can be replaced by \code{<\%=paste(letters, LETTERS, sep="/", collapse=", ")\%>}.}: 'The <%=n <- length(letters)%> letters in the English alphabet are: 
<% for (i in 1:n) { %>
  <%=letters[i]%>/<%=LETTERS[i]%><%=if(i < n) ", "%>
<% } %>.'\\

A more complex example is where one wish to generate a report on human genomic data across all of the 24 chromosomes and where the same type of analysis should be repeated for each chromosome.  With RSP markup, this can be achieved by an outer loop over chromosomes:
\begin{rspVerbatim}
<\% for (chromosome in 1:24) \{ %>
{\bs}section\{Chromosome <\%=chromosome\%>\}
...
A mix of RSP and text blocks constituting 
the analysis of the current chromosome.
...
<\% \} # for (chromosome ...) \%>
\end{rspVerbatim}

Note that there exist no corresponding markup in Sweave.  Instead, contrary to RSP, Sweave requires the each code chunk contains a complete R expression.  This means that, in terms of the above example, in Sweave it is not possible to begin a for loop in one code chunk and end it in a succeeding one.  This has to do with the fundamentally different way RSP and Sweave documents are processed.  If using Sweave, one solution to this is to use RSP to generate the Sweave document, e.g. \code{rsp("report.Rnw.rsp")}.



<%-------------------------------------------------------------------
  FIGURES
  -------------------------------------------------------------------%>
\section{Generating and inserting figures}
Since the above RSP markups are powerful enough, there is no need for a specific markup for figures.  This section shows how to create and embed image files into the final document.


%% \subsection{Creating image files}
The \code{toPDF()} and \code{toPNG()} functions of the \pkg{R.utils} package are useful when creating image files that are recognized by LaTeX.  For instance,
\begin{verbatim}
# Use greater objects by default
setOption("devNew/args/par", list(lwd=2));

toPDF("myFigure,yeah,cool", aspectRatio=0.6, { 
  curve(dnorm, from=-5, to=+5)
})
\end{verbatim}
creates a PDF image file named \code{myFigure,yeah,cool.png} whose height is 60\% of its width and displays the Guassian density distribution.
The function returns the filename without the filename extension, i.e. \code{"myFigure,yeah,cool"}.
  Moreover, (by default) these functions writes the image file to the figures/ directory.  For more information, see \code{help("toPDF")}.\\


%% \subsection{Brief on including image files in LaTeX}
When inserting a figure in LaTeX, it is recommended to do so without specifying neither the path nor the filename extension of the image file, e.g. \code{{\textbackslash}includegraphics\{MyFigure\}}.
In order for this to work, one must specify the "image search path", e.g.
\begin{verbatim}
\graphicspath{{figures/}{figures/external/}}
\end{verbatim}
which is preferably added to the beginning of the LaTeX file.  This tells LaTeX to search for image files in directory figures/ as well as directory figures/external/.   Moreover, when leaving out the filename extension, LaTeX will automatically search for image files with different filename extensions, e.g. \code{*.png} and \code{*.pdf}.

%% \subsection{Generating and embedding figures}
\begin{figure}[htp]
 \begin{center}
 \resizebox{0.70\textwidth}{!}{%
  \includegraphics{<%=toPDF("MyFigure,yeah,cool", aspectRatio=0.6, {
   curve(dnorm, from=-5, to=+5);
  })%>}
 }%
 \end{center}
 \caption{This figure was generated and inserted into the LaTeX document by RSP-embedded markup.}
 \label{fig:MyFigure}
\end{figure}

With this setup, it is possible to create and embed a figure as the one in Figure~\ref{fig:MyFigure} with the following tidy markup:
\begin{rspVerbatim}
{\bs}includegraphics\{<\%=toPDF("MyFigure,yeah,cool", aspectRatio=0.6, \{
  curve(dnorm, from=-5, to=+5);
\})\%>\}
\end{rspVerbatim}
After the RSP code has been processed, and the image file has been created, the above simply produces the following markup in the generated LaTeX document:
\begin{verbatim}
\includegraphics{MyFigure,yeah,cool}
\end{verbatim}
Note that by replacing \code{toPDF()} with \code{toPNG()}, a PNG image file is inserted instead, which can dramatically reduce the size of the final PDF document when for instance a high-density scatter plot is used.



<%-------------------------------------------------------------------
  ADDITIONAL FEATURES
  -------------------------------------------------------------------%>

\section{Templates - Reusing RSP and text blocks}
Sometimes rather similar paragraphs of text, tables, or figures are used throughout a document with only minor differences.  Instead of cut'n'pasting the same pieces of RSP and code to other places in the document, it is more robust and much easier to setup a template which is then reused in place.
Because of the nature of RSP, setting up a template is as simple as wrapping the mixture of RSP and code blocks in a function definition.  For example, assume you wish to reuse the following RSP and R blocks multiple times:
\begin{rspVerbatim}
The sum of $x=<\%=hpaste(1:n, abbreviate="{\bs}{\bs}ldots")\%>$ is <\%=sum(1:n)\%>.
\end{rspVerbatim}
Then place it in a function definition:
\begin{rspVerbatim}
<\% myTemplate <- function(n, ...) \{ \%>
The sum of $x=<\%=hpaste(1:n, abbreviate="{\bs}{\bs}ldots")\%>$ is <\%=sum(1:n)\%>.<\%----\%>
<\% \} # myTemplate() \%>
\end{rspVerbatim}
<% myTemplate <- function(n, ...) { %>
The sum of $x=<%=hpaste(1:n, abbreviate="\\ldots")%>$ is <%=sum(1:n)%>.<%----%>
<% } # myTemplate() %><%-- TO FIX: Should not be needed! /HB 2011-03-31 --%>
We use a trailing (empty) RSP comment (\code{<\%----\%>}) to escape the following newline.  Also, note that there is no limitation in how many RSP and text blocks you can use.  After having defined the template, it can be reused any number of times by simply calling it as a function:
\begin{rspVerbatim}
<\% myTemplate(n=3) \%>
\end{rspVerbatim}
which produces '<% myTemplate(n=3) %>'.  Without the trailing RSP comment, the final document would contain a whitespace after the period (and before the closing single-quote in the previous sentence).
A template can also be used within for loops.  For example:
\begin{rspVerbatim}
{\bs}begin\{itemize\}
<\% for (ii in c(3,5,10,100)) \{ \%>
 {\bs}item <\% myTemplate(n=ii) \%>
<\% \} # for (ii ...) \%>
{\bs}end\{itemize\}
\end{rspVerbatim}
produces:
\begin{itemize}
<% for (ii in c(3,5,10,100)) { %>
 \item <%= myTemplate(ii) %>
<% } # for (ii ...) %>
\end{itemize}



<%-------------------------------------------------------------------
  PREPROCESSING DIRECTIVES
  -------------------------------------------------------------------%>
\section{Preprocessing directives}
When an RSP-embedded document processed, it is first \emph{preprocessed} before it is \emph{translated} into an R script.  During this step it is possible to 
modify the document by removing parts of it and inserting new pieces to it.  For instance, by using the RSP hidden comments, multiple lines of the document can be silently dropped.

<%--, and by using the so called RSP 'insert' directive content of other files can be pasted into the document.
--%>


\subsection{Hidden (non-nested) comments (\code{<\%--\{anything\}--\%>})}
The RSP markup \code{<\%--\{anything\}--\%>} will be treated as a comment that can contain \emph{anything} (but \code{--\%>}), which will not be translated and not part of the output, i.e. it will immediately be dropped.  RSP comments are useful for excluding large sections of an RSP document.  It is useful to understand that RSP comments are \emph{greedy}, that is, anything between (and including) the \code{<\%--} and the \emph{first} following \code{--\%>} will be dropped, which means that they cannot be nested.
For example,
\begin{rspVerbatim}
<\%-- This is an RSP comment that will be dropped --\%>
You can write a paragraph and drop a large portion of it using 
RSP comments, <\%-- All the below will be dropped
There are <\%=n\%> red <\%=type\%>s
<\%-- and this --\%> but they must not be nested --\%>, because then
the output will be like this.
\end{rspVerbatim}
produces
\begin{verbatim}
<%-- This is an RSP comment that will be dropped --%>
You can write a paragraph and drop a large portion of it using 
RSP comments, <%-- All the below will be dropped
There are <%=n%> red <%=type%>s
<%-- and this --%> but they must not be nested --%>, because then
the output will be like this.
\end{verbatim}

Moreover, RSP comments are special in the sense that if (and only if) the remainder of the line following the comment consists of only whitespace symbols, then they are also dropped, including the newline.  Thus, an \code{<\%----\%>} at the end of a line will prevent a newline from being inserted.


<% if (docVersion == "devel") { %>
\subsection{Inserting files (\code{<\%\#insert file="\{pathname\}"\%>})}
The \emph{insert} directive can be used to insert the content of a file into the main RSP-embedded document \emph{just as if the content was pasted manually}.
 This makes it possible to reuse commonly used R scripts, text paragraphs, page layouts and so on.
For instance, assume that the file 'R/graphics.R' contains
\begin{verbatim}
setOption("devNew/args/par", list(lwd=2));
\end{verbatim}
Then it is possible to insert its content into a \code{<\%\{code\}\%>} block\footnote{Note, if the insert directive is not wrapped up in a \code{<\%\{code\}\%>} block, the inserted source code will be inserted as text to the document rather than as code.} of the main RSP-embedded document by:
\begin{rspVerbatim}
<\%
# Graphics settings
<\%\#insert file="R/graphics.R"\%>
\%>
\end{rspVerbatim}
which "updates" the main document to:
\begin{rspVerbatim}
<\%
# Graphics settings
setOption("devNew/args/par", list(lwd=2));
\%>
\end{rspVerbatim}
In addition to the \code{file} attribute, the insert directive also takes an optional \code{path} attribute, which provides an alternative for specifying the path, e.g. \code{<\%\#insert file="graphics.R" path="R/"\%>}.\\

It is also possible to insert the content of all files in a directory that match a given \emph{filename pattern}, which is specified by the \code{pattern} attribute.  For instance,
\begin{rspVerbatim}
<\%\#insert path="R/" pattern="[.]R$"\%>
\end{rspVerbatim}
inserts the content of all *.R files that are available in the R/ directory.\footnote{Files are guaranteed to be inserted in lexicographic order when using the 'insert' preprocessing directive.  Their content is by default concatenated using the newline symbol, which can be changed by setting the \code{collapse} attribute.}\\

Finally, it is important to understand that the paths used for inserting these files are all relative to the current working directory of R \emph{at the time of the preprocessing}\footnote{The current working directory as seen by the RSP preprocessor \emph{cannot} be modified via a \code{<\%setwd(newPath)\%>} construct, because that is only evaluated after the preprocessing step.}.

<% } # if (docVersion == "devel") %>


<% if (docVersion == "devel") { %>
<%-------------------------------------------------------------------
  RSP-EMBEDDED SWEAVE DOCUMENTS
  -------------------------------------------------------------------%>
\section{RSP-embedded Sweave documents}
We advocate using RSP over Sweave, because of its richness and generality to the underlying document format.  However, for Sweave users, we will in this section show how to enhance Sweave with RSP-embedded markup to circumvent a few of Sweave's shortcomes.


\subsection{Programmatically setting Sweave code chunk options}

In the R-help thread 'sweave options with variable' on 2011-04-17, it was asked if it is possible to use a variable to control the 'eval' option of a code chunk, e.g. \code{<<eval=needRun>>=} instead of \code{<<eval=TRUE>>=} or \code{<<eval=FALSE>>=}.  As explained in the thread, this is not possible to do in plain Sweave, but using RSP it is straightforward:
\begin{rspVerbatim}
<\% needRun <- TRUE \%>
<<eval=<\%=needRun\%>>>=
someSlowFunction()
@
\end{rspVerbatim}
Without RSP the following workaround will achieve the same effect:
\begin{verbatim}
<<echo=FALSE>>=
needRun <- TRUE
@

...

<<thecode,eval=FALSE>>=
someSlowFunction()
@

<<echo=FALSE>>=
if (needRun) {
<<thecode>>
}
@
\end{verbatim}


\subsection{Iterating over a mixture of code and text blocks}
As mention above, it is not possible to programmatically loop over a mixture of text and code chunks in Sweave.  A workaround for this is to use RSP markup to define the loop.  For example, in Sweave the following\footnote{This example is taken from the Sweave User Manual part of the \pkg{utils} package.} does not work
\begin{verbatim}
<<fig=TRUE>>
for (i in 1:4) plot(rnorm(100)+i)
@
\end{verbatim}
With RSP, one can do
\begin{rspVerbatim}
<\% for (kk in 1:4) \{ \%>
<<fig=TRUE, echo=FALSE>>=
  i <- <\%=kk\%>  <\%-- NOTE: Sweave does not see RSP variables! --\%>
  plot(rnorm(100)+i)
@
<\% \} # for (kk ...) \%>
\end{rspVerbatim}
This will expand to four \code{<<fig=TRUE, echo=FALSE>>=\,[...]\,@} chunks before Sweave sees it.
Alternative, one might want to use an \emph{RSP template} to tidy it up further, e.g.
\begin{rspVerbatim}
<\% mySweaveFigure <- function(kk, ...) \{ \%>
<<fig=TRUE, echo=FALSE>>=
  i <- <\%=kk\%>  <\%-- NOTE: Sweave does not see RSP variables! --\%>
  plot(rnorm(100)+i)
@
<\% \} # mySweaveFigure() \%>
\end{rspVerbatim}
and then generate the four Sweave figure chunks by
\begin{rspVerbatim}
<\% for (kk in 1:4) \{ mySweaveFigure(kk) \} \%>
\end{rspVerbatim}


Without RSP, the workaround is to manually generate the image files and have the code output the correct LaTeX commands much like one would do without Sweave, e.g.
\begin{verbatim}
<<results=tex,echo=FALSE>>=
for (i in 1:4) {
  fn <- paste("myfile", i, ".pdf", sep="")
  pdf(file=fn, width=6, height=6)
  plot(rnorm(100)+i)
  dev.off()
  cat("\\includegraphics{", fn, "}\n\n", sep = "")
}
@
\end{verbatim}
This latter approach is error prone, especially because of how the LaTeX code has to be escaped and generated using R code.
<% } # if (docVersion == "devel") %>


<% if (docVersion == "devel") { %>
<%-------------------------------------------------------------------
  COMPARISON TO OTHER METHODS
  -------------------------------------------------------------------%>
\section{Brief comparison to other markup languages}

\begin{table}[htb]
\begin{center}
\begin{tabular}{lccc}
Feature & RSP & brew & Sweave \\
\hline
Context-independent processing                 & yes & yes &  - \\
Interweaving incomplete code and text snippets & yes & yes &  - \\
Preprocessing markup                           & yes &   - &  - \\
Hidden markup comments                         & yes &   - &  - \\
Multiline markup comments                      & yes &   ? &  - \\
"As-is" insertion of other files               & yes &   ? &  - \\
\hline
\end{tabular}
\end{center}
\caption{Comparison of features in different R-related markup languages.}
\end{table}
<% } # if (docVersion == "devel") %>


<%-------------------------------------------------------------------
  APPENDIX
  -------------------------------------------------------------------%>
\clearpage
\section*{Appendix}
\subsection*{Session information}
<%=toLatex(sessionInfo())%>
This report was automatically generated using \code{rsp()} of the R.rsp package.
Total processing time after RSP-to-R translation was <%=dt <- round(Sys.time()-t0, digits=2)%> <%=attr(dt, "units")%>.

\end{document}
